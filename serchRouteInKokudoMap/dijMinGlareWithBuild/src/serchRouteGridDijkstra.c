#include<stdio.h>#include<stdlib.h>#include<string.h>#include<math.h>#include"header.h"/* 速度の値　km/h -> m/min に変換*/static int convertVelHourMin(int vel_kph){	return vel_kph / 60 * 1000;}/* 始発点と終着点の連結性をチェック 繋がっていないならばエラーメッセージを表示する*/static void checkConnectedStartToGoal(int min_uncom, int start, int goal){	//printf("min_uncom = %d\n", min_uncom);	if(min_uncom == INF){		printf("not connected start to goal\n");		printf("%d -> %d\n", start, goal);		exit(1);	}	return;}/* 2点間の距離を計算する関数 */static double getDist(struct xy_coord_t p1, struct xy_coord_t p2){	return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));}/* 2点間の角度を計算する					(北:90度)（西:180度） 　　　　　　（東:0度）　　　　　　　（南:270度）*/static double getEdgeAngle(struct xy_coord_t p1, struct xy_coord_t p2){	double radian = atan2(p2.y - p1.y, p2.x - p1.x);	double deg = radian * 180 / M_PI;	if(deg < 0)		return deg + 180;	else		return deg;}static double getUncom(double trav_time, double edge_angle, double arrival_time, struct xy_coord_t ed_begin_pos, struct build_grid_t** build_grid, struct grid_size_t grid_size){	struct sun_angle_t sun_angle;	double glare;	int sun_state;		sun_angle = getSunAngle(fmod(arrival_time/60, 24.0f));	if(edge_angle > 180.0f || edge_angle < -180.0f)		printf("azim = %f, edge_angle = %f\n", sun_angle.azim, edge_angle);	if(sun_angle.elev <= SUN_HIGH && sun_angle.elev >= SUN_LOW && fabs(sun_angle.azim - edge_angle) < SUN_WIDTH){		switch(BUILD_MODE){			case 0:				sun_state = FALSE;				break;			case 1: 				sun_state = getSunStateWithBuildFromGrid(sun_angle, ed_begin_pos, build_grid, grid_size);				break;			default:				printf("invailed BUILD_MODE value %d\n", BUILD_MODE);				exit(1);		}		if(sun_state == TRUE){			return trav_time;		}		else{			glare = getGlare(sun_angle, edge_angle);			return glare * trav_time;		}	}	else{		return trav_time;	}}static void printOptimumRoute(int* prev, int p, struct vertex_t* vertex){	while(prev[p] != EMPTY){		printf("%f %f\n", vertex[prev[p]].node.pos.x, vertex[prev[p]].node.pos.y);		p = prev[p];	}	return;}void serchRouteGridDijkstra(struct vertex_t* vertex, int node_size, int start, int goal, struct time_t dptr, int vel_kph, struct build_grid_t** build_grid, struct grid_size_t grid_size){	double uncom[node_size], time[node_size], min_uncom = INF;	//int path_time[node_size];	int flag[node_size];	int i, j, p, index_num = 0;	int prev[node_size];	double dist, trav_time, edge_angle, edge_uncom, arrival_time;	/* 速度（m/min）の変換 */	int vel_mph = convertVelHourMin(vel_kph);		/* 距離配列と探索配列の初期化 */	for(i=1;i<node_size;i++){		uncom[i] = INF;		flag[i] = FALSE;		prev[i] = EMPTY;		time[i] = EMPTY;		vertex[i].adj_list_p = vertex[i].adj_list_head;	}		/* 始点ノードのコスト，時刻を格納*/	uncom[start] = 0.0f;	time[start] = dptr.hour * 60 + dptr.min;	//printf("time[start] = %f\n", time[start]);	//printf("%f\n", fmod(time[start] / 60, 24.0f));		for(i=1;i<node_size;i++){		min_uncom = INF;		/* 最小節点の探索 */				/* 		コストは分かっているがその頂点への最適経路が確定されていない頂点を探索 		最適経路は各確定済み頂点からの最適経路		*/		for(j=1;j<node_size;j++){			if(uncom[j] != INF){				if(flag[j] == FALSE){					if(uncom[j] < min_uncom || min_uncom == INF){						index_num = j;						min_uncom = uncom[j];					}				}			}		}		/* 最小距離の節点に確定フラグを立てる */		flag[index_num] = TRUE;		checkConnectedStartToGoal(min_uncom, start, goal);		/* 		vertex[index_num]との辺を保持するvertexとの不快度及び到着時刻を算出する		*/		while(vertex[index_num].adj_list_p != NULL){			/* 探索点から各節点への距離を計算 */			dist = getDist(vertex[index_num].node.pos, vertex[vertex[index_num].adj_list_p->num].node.pos);			trav_time = dist / vel_mph;			arrival_time = time[index_num] + trav_time;			edge_angle = getEdgeAngle(vertex[index_num].node.pos, vertex[vertex[index_num].adj_list_p->num].node.pos);			edge_uncom = getUncom(trav_time, edge_angle, arrival_time, vertex[index_num].node.pos, build_grid, grid_size);			/* 今までの節点の最小距離より低いならば，最小距離の更新 */			if(uncom[index_num] +  edge_uncom < uncom[vertex[index_num].adj_list_p->num] || uncom[vertex[index_num].adj_list_p->num] == INF){				uncom[vertex[index_num].adj_list_p->num] = uncom[index_num] + edge_uncom;				time[vertex[index_num].adj_list_p->num] = time[index_num] + trav_time;				prev[vertex[index_num].adj_list_p->num] = index_num;			}			vertex[index_num].adj_list_p = vertex[index_num].adj_list_p->next;			//printf("%p  %p\n", vertex[index_num].adj_list_p, vertex[index_num].adj_list_p->next);		}		vertex[index_num].adj_list_p = vertex[index_num].adj_list_head;		if(index_num == goal)			break;	}	p = goal;		printf("%f\n", uncom[goal]);	if(PRINT_ROUTE == 1)		printOptimumRoute(prev, p, vertex);			return;}