#include<stdio.h>#include<stdlib.h>#include<string.h>#include<math.h>#include"header.h"/* 速度の値　km/h -> m/min に変換*/static double convertVelHourMin(int vel_kph){	return (double)vel_kph / 60.0f * 1000;}/* 始発点と終着点の連結性をチェック 繋がっていないならばエラーメッセージを表示する*/static void checkConnectedStartToGoal(int min_uncom, int start, int goal){	//printf("min_uncom = %d\n", min_uncom);	if(min_uncom == INF){		printf("not connected start to goal\n");		printf("%d -> %d\n", start, goal);		exit(1);	}	return;}/* 2点間の距離を計算する関数 */static double getDist(struct xy_coord_t p1, struct xy_coord_t p2){	return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));}double  serchRouteDistDijkstra(struct vertex_t* vertex, int node_size, int start, int goal, int vel_kph){	double travt[node_size]; //各頂点への不快度，到着時刻，移動時間	double min_travt = INF;	int flag[node_size];	int i, j, index_num = 0;	double dist, trav_time;	/* 速度（m/min）の変換 */	double vel_mph = convertVelHourMin(vel_kph);		/* 距離配列と探索配列の初期化 */	for(i=1;i<node_size;i++){		travt[i] = INF;		flag[i] = FALSE;		vertex[i].adj_list_p = vertex[i].adj_list_head;	}		/* 始点ノードのコストを格納*/	travt[start] = 0.0f;		for(i=1;i<node_size;i++){		min_travt = INF;		/* 最小節点の探索 */				/* 		コストは分かっているがその頂点への最適経路が確定されていない頂点を探索 		最適経路は各確定済み頂点からの最適経路		*/		for(j=1;j<node_size;j++){			if(travt[j] != INF){				if(flag[j] == FALSE){					if(travt[j] < min_travt || min_travt == INF){						index_num = j;						min_travt = travt[j];					}				}			}		}		/* 最小距離の節点に確定フラグを立てる */		flag[index_num] = TRUE;				/* 始発点と帰着点が連結しているかをチェックする	*/		checkConnectedStartToGoal(min_travt, start, goal);		/* 		vertex[index_num]との辺を保持するvertexとの不快度及び到着時刻を算出する		*/		while(vertex[index_num].adj_list_p != NULL){			/* 探索点から各節点への距離を計算 */			dist = getDist(vertex[index_num].node.pos, vertex[vertex[index_num].adj_list_p->num].node.pos);			trav_time = dist / vel_mph;			/* 今までの節点の最小距離より低いならば，最小距離の更新 */			if(travt[index_num] +  trav_time < travt[vertex[index_num].adj_list_p->num] || travt[vertex[index_num].adj_list_p->num] == INF){				travt[vertex[index_num].adj_list_p->num] = travt[index_num] + trav_time;			}			vertex[index_num].adj_list_p = vertex[index_num].adj_list_p->next;			//printf("%p  %p\n", vertex[index_num].adj_list_p, vertex[index_num].adj_list_p->next);		}		vertex[index_num].adj_list_p = vertex[index_num].adj_list_head;		if(index_num == goal)			break;	}		//printf("travt : %f\n", travt[goal]);			return travt[goal];}