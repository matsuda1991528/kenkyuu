#include<stdio.h>#include<stdlib.h>#include<math.h>#include"header.h"struct min_max_t{	double min;	double max;};//ラジアン変換static double getRadian(double deg){	return deg * M_PI / 180.0f;}static double getY_axisShadowLength(double target_height, struct sun_angle_t sun_angle){	double shadow_length; //日影長		shadow_length = target_height * (1 / tan(getRadian(sun_angle.elev)));	return shadow_length * sin(getRadian(sun_angle.azim));}//最大の影の長さを返す．static double getMaxLength(double origin_length, double target_length){	if(origin_length < target_length)		return target_length;	else		return origin_length;}double getGridLength(void){	int hour, min;	int just_appear_sun_hour; //太陽が現れる直前の時刻[h]	struct sun_angle_t current_sun_angle; //太陽角度	double before_elev = 9999;	double yaxis_shadow_length; //y軸方向への影の長さ	double y_max_shadow_length = EMPTY; //y軸方向への最大の影の長さ		for(hour=18;hour<24;hour++){		current_sun_angle = getSunAngle(hour);				if(before_elev > SUN_HIGH && current_sun_angle.elev <= SUN_HIGH){			just_appear_sun_hour = hour - 1;			break;		}				before_elev = current_sun_angle.elev;	}		min = just_appear_sun_hour * 60;	current_sun_angle = getSunAngle(fmod((double)min / 60.0f, 24.0f));	/*	影のy(南北)方向への最大長を求める．	1分刻みで各時刻の太陽位置における日影のy方向への長さを求める．	*/	while(1){		current_sun_angle = getSunAngle(fmod((double)min / 60.0f, 24.0f));		if(current_sun_angle.elev < SUN_LOW)			break;					if(current_sun_angle.elev <= SUN_HIGH){			yaxis_shadow_length = getY_axisShadowLength(BUILD_HIGH, current_sun_angle);			y_max_shadow_length = getMaxLength(y_max_shadow_length, yaxis_shadow_length);		}		min++;	}		return y_max_shadow_length;}struct min_max_t getEndPointInYaxis(struct build_pos_t* head){	struct build_pos_t *p;	struct min_max_t whole_map_end;		whole_map_end.min = whole_map_end.max = EMPTY;	p = head;	p = p->next;	/*全体の建物データから最小のyと最大のyを求める．*/	while(p != NULL){		if(p->pos.y < whole_map_end.min || whole_map_end.min == EMPTY)			whole_map_end.min = p->pos.y;				if(p->pos.y > whole_map_end.max || whole_map_end.max == EMPTY)			whole_map_end.max = p->pos.y;				p = p->next;	}		return whole_map_end;}		/* 各グリッドの南端と北端のy座標を割り当てる． */static void assignGridArea(struct build_grid_t* build_grid, double grid_length, struct min_max_t whole_map_end, int grid_size){	int i;	for(i=1;i<grid_size;i++){		build_grid[i].min_y = whole_map_end.min + grid_length * (i - 1);		build_grid[i].max_y = whole_map_end.min + grid_length * i;	}	return;}/* struct build_pos_t型分のメモリを確保し，struct build_pos_t*　へキャストする */static struct build_pos_t *buildMalloc(void){	return (struct build_pos_t *)malloc(sizeof(struct build_pos_t));}void initBuildGrid(struct build_grid_t* build_grid, int grid_size){	int i;	for(i=1;i<grid_size;i++){		build_grid[i].head = buildMalloc();		build_grid[i].old = build_grid[i].head;	}	return;}//建物データのコピーvoid copyBuild(struct build_pos_t* target_build, struct build_pos_t* origin_build){	//printf("%f, %f, %f\n", origin_build->pos.x, origin_build->pos.y, origin_build->width);	target_build->pos.x = origin_build->pos.x;	target_build->pos.y = origin_build->pos.y;	target_build->width = origin_build->width;		return;}static void assignBuildToGrid(struct build_pos_t* head, struct build_grid_t* build_grid, int grid_size){	struct build_pos_t *p;	int i;		initBuildGrid(build_grid, grid_size);	p = head;	p = p->next;	while(p != NULL){		for(i=1;i<=grid_size;i++){			if(p->pos.y >= build_grid[i].min_y && p->pos.y < build_grid[i].max_y) {				build_grid[i].p = buildMalloc();				copyBuild(build_grid[i].p, p);								build_grid[i].old->next = build_grid[i].p;				build_grid[i].old = build_grid[i].p;				break;			}			if(i == grid_size){				printf("koitu okasii-> %f %f\n", p->pos.x, p->pos.y);				exit(1);			}		}		p = p->next;	}		for(i=1;i<grid_size;i++)		build_grid[i].old->next = NULL;		return;}/* グリッドマップをファイル書き込み */static void fprintGridMap(struct build_grid_t* build_grid, int grid_size){	FILE *fp;	char fname[MAX_LEN]; //配列でないとsprintfでsegmentation faultが発生る．	int i;	for(i=1;i<grid_size;i++){		//ファイル名の作成		sprintf(fname, "..\\build_grid\\grid_map_%d.dat", i);		//ファイルのを作成		fileOpenCheck(&fp, fname, "w+");		//建物データの書き込み		build_grid[i].p = build_grid[i].head;		build_grid[i].p = build_grid[i].p->next;		while(build_grid[i].p != NULL){			fprintf(fp, "%f %f\n", build_grid[i].p->pos.x, build_grid[i].p->pos.y);			build_grid[i].p = build_grid[i].p->next;		}	}		return;}struct build_grid_t* createGridMap(struct build_pos_t* head, struct build_grid_t* build_grid, int* grid_size){	struct min_max_t whole_map_end;	double grid_length; //各グリッドの南北(y軸)方向の長さ	//int grid_size; //グリッド数＋1	//struct build_grid_t *build_grid;		grid_length = getGridLength();	whole_map_end = getEndPointInYaxis(head);	*grid_size = (int)(floor((whole_map_end.max - whole_map_end.min) / grid_length) + 2);	//printf("grid_length = %f\n", grid_length);	//printf("min_y : %f  max_y : %f\n", whole_map_end.min, whole_map_end.max);	//printf("grid_size = %d\n", *grid_size);		/* グリッドマップの記憶領域の取得 */	build_grid = (struct build_grid_t *)malloc(sizeof(struct build_grid_t) * *grid_size);	assignGridArea(build_grid, grid_length, whole_map_end, *grid_size);		assignBuildToGrid(head, build_grid, *grid_size);		fprintGridMap(build_grid, *grid_size);		return build_grid;}		