#include<stdio.h>#include<stdlib.h>#include<math.h>#include"header.h"struct min_max_t{	double min;	double max;};//ラジアン変換static double getRadian(double deg){	return deg * M_PI / 180.0f;}struct xy_coord_t getXY_axisShadowLength(double target_height, struct sun_angle_t sun_angle){	double shadow_length; //日影長	struct xy_coord_t xy_shadow_length;  //xy軸方向への影の長さ		shadow_length = target_height * (1 / tan(getRadian(sun_angle.elev)));	xy_shadow_length.y = fabs(shadow_length * sin(getRadian(sun_angle.azim)));	xy_shadow_length.x = fabs(shadow_length * cos(getRadian(sun_angle.azim)));	return xy_shadow_length;}//最大の影の長さを返す．static double getMaxLength(double origin_length, double target_length){	if(origin_length < target_length || origin_length == EMPTY)		return target_length;	else		return origin_length;}struct xy_coord_t getGridLength(void){	int hour, min;	int just_appear_sun_hour; //太陽が現れる直前の時刻[h]	struct sun_angle_t current_sun_angle; //太陽角度	double before_elev = 9999;	struct xy_coord_t xy_shadow_length; //xとy軸方向への影の長さ	struct xy_coord_t xy_max_shadow_length; //y軸方向への最大の影の長さ	xy_max_shadow_length.x = xy_max_shadow_length.y = EMPTY;		//フロントガラスによって太陽が遮蔽されない直前の時刻[h]を求める	for(hour=18;hour<24;hour++){		current_sun_angle = getSunAngle(hour);				if(before_elev > SUN_HIGH && current_sun_angle.elev <= SUN_HIGH){			just_appear_sun_hour = hour - 1;			break;		}				before_elev = current_sun_angle.elev;	}		min = just_appear_sun_hour * 60;	current_sun_angle = getSunAngle(fmod((double)min / 60.0f, 24.0f));	/*	影のy(南北)方向への最大長を求める．	1分刻みで各時刻の太陽位置における日影のy方向への長さを求める．	*/	while(1){		current_sun_angle = getSunAngle(fmod((double)min / 60.0f, 24.0f));		if(current_sun_angle.elev < SUN_LOW)			break;					if(current_sun_angle.elev <= SUN_HIGH){			xy_shadow_length = getXY_axisShadowLength(BUILD_HIGH, current_sun_angle);			xy_max_shadow_length.y = getMaxLength(xy_max_shadow_length.y, xy_shadow_length.y);			xy_max_shadow_length.x = getMaxLength(xy_max_shadow_length.x, xy_shadow_length.x);		}		min++;	}		return xy_max_shadow_length;}struct min_max_t getEndPointInYaxis(struct build_pos_t* head){	struct build_pos_t *p;	struct min_max_t whole_map_end;		whole_map_end.min = whole_map_end.max = EMPTY;	p = head;	p = p->next;	/*全体の建物データから最小のyと最大のyを求める．*/	while(p != NULL){		if(p->pos.y < whole_map_end.min || whole_map_end.min == EMPTY)			whole_map_end.min = p->pos.y;				if(p->pos.y > whole_map_end.max || whole_map_end.max == EMPTY)			whole_map_end.max = p->pos.y;				p = p->next;	}		return whole_map_end;}struct min_max_t getEndPointInXaxis(struct build_pos_t* head){	struct build_pos_t *p;	struct min_max_t whole_map_end;		whole_map_end.min = whole_map_end.max = EMPTY;	p = head;	p = p->next;	/*全体の建物データから最小のxと最大のxを求める．*/	while(p != NULL){		if(p->pos.x < whole_map_end.min || whole_map_end.min == EMPTY)			whole_map_end.min = p->pos.x;				if(p->pos.x > whole_map_end.max || whole_map_end.max == EMPTY)			whole_map_end.max = p->pos.x;				p = p->next;	}		return whole_map_end;}		/* 各グリッドの最小と最大のxy座標を割り当てる． */static void assignGridArea(struct build_grid_t** build_grid, struct xy_coord_t grid_length, struct min_max_t whole_map_end_y, struct min_max_t whole_map_end_x, struct grid_size_t* grid_size){	int i, j;	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].min.y = whole_map_end_y.min + grid_length.y * (i - 1);			build_grid[i][j].max.y = whole_map_end_y.min + grid_length.y * i;			build_grid[i][j].min.x = whole_map_end_x.min + grid_length.x * (j - 1);			build_grid[i][j].max.x = whole_map_end_x.min + grid_length.x * j;						/* 			地図に対する建物の位置の値域幅と交差点を示す頂点の位置の値域幅は異なる．			そこで，建物地図外に頂点が位置した場合は近傍のグリッドに位置するようにする．			*/			if(i == 1)				build_grid[i][j].min.y = 0.0f;			else if(i == grid_size->vertical - 1)				build_grid[i][j].max.y = whole_map_end_y.max * 2;			if(j == 1)				build_grid[i][j].min.x = 0.0f;			else if(j == grid_size->width - 1)				build_grid[i][j].max.x = whole_map_end_x.max * 2;		}	}	return;}/* struct build_pos_t型分のメモリを確保し，struct build_pos_t*　へキャストする */static struct build_pos_t *buildMalloc(void){	return (struct build_pos_t *)malloc(sizeof(struct build_pos_t));}/* 各グリッドの建物データの先頭リストのメモリ領域を確保 */void initBuildGrid(struct build_grid_t** build_grid, struct grid_size_t* grid_size){	int i, j;	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].head = buildMalloc();			build_grid[i][j].old = build_grid[i][j].head;		}	}	return;}//建物データのコピーvoid copyBuild(struct build_pos_t* target_build, struct build_pos_t* origin_build){	//printf("%f, %f, %f\n", origin_build->pos.x, origin_build->pos.y, origin_build->width);	target_build->pos.x = origin_build->pos.x;	target_build->pos.y = origin_build->pos.y;	target_build->width = origin_build->width;		return;}static void assignBuildToGrid(struct build_pos_t* head, struct build_grid_t** build_grid, struct grid_size_t* grid_size){	struct build_pos_t *p;	int i, j;		initBuildGrid(build_grid, grid_size);	//先頭リストはダミーなのです！	p = head;	p = p->next;		//建物をグリッドに割り当てる．	//各建物グリッド地図のy幅とx幅の中に存在する条件を満たしたらならば	//建物を該当した建物地図に割り当てる	while(p != NULL){		for(i=1;i<grid_size->vertical;i++){			for(j=1;j<grid_size->width;j++){				if(p->pos.y >= build_grid[i][j].min.y && p->pos.y < build_grid[i][j].max.y				  && p->pos.x >= build_grid[i][j].min.x && p->pos.x < build_grid[i][j].max.x){					build_grid[i][j].p = buildMalloc();					copyBuild(build_grid[i][j].p, p);									build_grid[i][j].old->next = build_grid[i][j].p;					build_grid[i][j].old = build_grid[i][j].p;					break;				}			}		}		p = p->next;	}		for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].old->next = NULL;		}	}		return;}/* グリッドマップをファイル書き込み */static void fprintGridMap(struct build_grid_t** build_grid, struct grid_size_t* grid_size){	FILE *fp;	char fname[MAX_LEN]; //配列でないとsprintfでsegmentation faultが発生る．	int i, j;	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			//ファイル名の作成			sprintf(fname, "..\\build_grid\\grid_map_%d_%d.dat", i, j);			//ファイルのを作成			fileOpenCheck(&fp, fname, "w+");			//建物データの書き込み			build_grid[i][j].p = build_grid[i][j].head;			build_grid[i][j].p = build_grid[i][j].p->next;			while(build_grid[i][j].p != NULL){				fprintf(fp, "%f %f\n", build_grid[i][j].p->pos.x, build_grid[i][j].p->pos.y);				build_grid[i][j].p = build_grid[i][j].p->next;			}		}	}		return;}//グリッドマップの生成struct build_grid_t** createGridMap(struct build_pos_t* head, struct build_grid_t** build_grid, struct grid_size_t* grid_size){	struct min_max_t whole_map_end_y;	struct min_max_t whole_map_end_x;	struct xy_coord_t grid_length; //各グリッドのxy方向の長さ	int i;		if(GRID_PATTERN == 0){		if(grid_scale_fact == EMPTY){			printf("invailed grid_scale_fact -> %f\n", grid_scale_fact);			exit(1);		}		else{			grid_length = getGridLength();			grid_length.x = grid_length.x * grid_scale_fact;			grid_length.y = grid_length.y * grid_scale_fact;		}	}	else if(GRID_PATTERN == 1)		grid_length = g_size;		//全体地図の最小と最大のxy座標を求める．	whole_map_end_y = getEndPointInYaxis(head);	whole_map_end_x = getEndPointInXaxis(head);		grid_size->vertical = (int)(floor((whole_map_end_y.max - whole_map_end_y.min) / grid_length.y) + 2);	grid_size->width =  (int)(floor((whole_map_end_x.max - whole_map_end_x.min) / grid_length.x) + 2);		//printf("%f %f\n", grid_length.x, grid_length.y);	//printf("min = %f, %f\n", whole_map_end_x.min, whole_map_end_y.min);	//printf("max = %f, %f\n", whole_map_end_x.max, whole_map_end_y.max);	//printf("whole_width : %f   whole_vertical : %f\n", whole_map_end_x.max - whole_map_end_x.min, whole_map_end_y.max - whole_map_end_y.min);	//printf("grid_size = %d %d\n", grid_size->vertical, grid_size->width);		/* グリッドマップの記憶領域の取得 */	build_grid = (struct build_grid_t *)malloc(sizeof(struct build_grid_t) * grid_size->vertical);	for(i=1;i<grid_size->vertical;i++)		build_grid[i] = (struct build_grid_t *)malloc(sizeof(struct build_grid_t) * grid_size->width);			assignGridArea(build_grid, grid_length, whole_map_end_y, whole_map_end_x, grid_size);		assignBuildToGrid(head, build_grid, grid_size);		//fprintGridMap(build_grid, grid_size);		return build_grid;}		