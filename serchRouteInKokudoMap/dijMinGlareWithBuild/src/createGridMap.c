#include<stdio.h>#include<stdlib.h>#include<math.h>#include<sys/stat.h>#include"header.h"struct min_max_t{	double min;	double max;};struct min_max_t getEndPointInYaxis(struct build_pos_t* head){	struct build_pos_t *p;	struct min_max_t whole_map_end;		whole_map_end.min = whole_map_end.max = EMPTY;	p = head;	p = p->next;		whole_map_end.min = p->pos.y;	whole_map_end.max = p->pos.x;	p = p->next;	/*全体の建物データから最小のyと最大のyを求める．*/	while(p != NULL){		if(p->pos.y < whole_map_end.min)			whole_map_end.min = p->pos.y;				if(p->pos.y > whole_map_end.max || whole_map_end.max == EMPTY)			whole_map_end.max = p->pos.y;				p = p->next;	}		return whole_map_end;}struct min_max_t getEndPointInXaxis(struct build_pos_t* head){	struct build_pos_t *p;	struct min_max_t whole_map_end;		whole_map_end.min = whole_map_end.max = EMPTY;	p = head;	p = p->next;	/*全体の建物データから最小のxと最大のxを求める．*/	while(p != NULL){		if(p->pos.x < whole_map_end.min || whole_map_end.min == EMPTY)			whole_map_end.min = p->pos.x;				if(p->pos.x > whole_map_end.max || whole_map_end.max == EMPTY)			whole_map_end.max = p->pos.x;				p = p->next;	}		return whole_map_end;}		/* 各グリッドの最小と最大のxy座標を割り当てる． */static void assignGridArea(struct build_grid_t** build_grid, struct xy_coord_t grid_length, struct min_max_t whole_map_end_y, struct min_max_t whole_map_end_x, struct grid_size_t* grid_size){	int i, j;	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].min.y = whole_map_end_y.min + grid_length.y * i;			build_grid[i][j].max.y = whole_map_end_y.min + grid_length.y * (i + 1);			build_grid[i][j].min.x = whole_map_end_x.min + grid_length.x * j;			build_grid[i][j].max.x = whole_map_end_x.min + grid_length.x * (j + 1);						/* 			地図に対する建物の位置の値域幅と交差点を示す頂点の位置の値域幅は異なる．			（例）→建物頂点の東端は東経130度に対し，交差点頂点の東端は134度の場合			そこで，建物地図外に頂点が位置した場合は近傍のグリッドに位置するようにする．			*/			/*			if(i == 1)				build_grid[i][j].min.y = 0.0f;			else if(i == grid_size->vertical - 1)				build_grid[i][j].max.y = whole_map_end_y.max * 2;			if(j == 1)				build_grid[i][j].min.x = 0.0f;			else if(j == grid_size->width - 1)				build_grid[i][j].max.x = whole_map_end_x.max * 2;			*/			if(i == grid_size->vertical - 1)				build_grid[i][j].max.y = whole_map_end_y.max * 2;			 if(j == grid_size->width - 1)				build_grid[i][j].max.x = whole_map_end_x.max * 2;		}	}		build_grid[0][0].min.x = build_grid[0][0].min.y = 0.0f;	build_grid[0][0].max.x = build_grid[1][1].min.x;	build_grid[0][0].max.y = build_grid[1][1].min.y;	return;}/* struct build_pos_t型分のメモリを確保し，struct build_pos_t*　へキャストする */static struct build_pos_t *buildMalloc(void){	return (struct build_pos_t *)malloc(sizeof(struct build_pos_t));}/* 各グリッドの建物データの先頭リストのメモリ領域を確保 */void initBuildGrid(struct build_grid_t** build_grid, struct grid_size_t* grid_size){	int i, j;	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].head = buildMalloc();			build_grid[i][j].old = build_grid[i][j].head;		}	}	return;}//建物データのコピーvoid copyBuild(struct build_pos_t* target_build, struct build_pos_t* origin_build){	//printf("%f, %f, %f\n", origin_build->pos.x, origin_build->pos.y, origin_build->width);	target_build->pos.x = origin_build->pos.x;	target_build->pos.y = origin_build->pos.y;	target_build->width = origin_build->width;		return;}static void assignBuildToGrid(struct build_pos_t* head, struct build_grid_t** build_grid, struct grid_size_t* grid_size){	struct build_pos_t *p;	int i, j;		initBuildGrid(build_grid, grid_size);	//先頭リストはダミーなのです！	p = head;	p = p->next;		//建物をグリッドに割り当てる．	//各建物グリッド地図のy幅とx幅の中に存在する条件を満たしたらならば	//建物を該当した建物地図に割り当てる	while(p != NULL){		i = (int)(p->pos.y - (int)build_grid[1][1].min.y) / (int)g_size.y;		j = (int)(p->pos.x - (int)build_grid[1][1].min.x) / (int)g_size.x;		if(i < 1)			i = 1;		if(j < 1)			j = 1;		build_grid[i][j].p = buildMalloc();		copyBuild(build_grid[i][j].p, p);			build_grid[i][j].old->next = build_grid[i][j].p;		build_grid[i][j].old = build_grid[i][j].p;/*		for(i=1;i<grid_size->vertical;i++){			if(build_grid[i][1].min.y <= p->pos.y && p->pos.y <build_grid[i][1].max.y){				for(j=1;j<grid_size->width;j++){					if(p->pos.x >= build_grid[i][j].min.x && p->pos.x < build_grid[i][j].max.x){						build_grid[i][j].p = buildMalloc();						copyBuild(build_grid[i][j].p, p);											build_grid[i][j].old->next = build_grid[i][j].p;						build_grid[i][j].old = build_grid[i][j].p;						break;					}				}			}		}	*/		p = p->next;	}		for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			build_grid[i][j].old->next = NULL;		}	}		return;}/* グリッドマップをファイル書き込み */static void fprintGridMap(struct build_grid_t** build_grid, struct grid_size_t* grid_size){	FILE *fp;	char fname[MAX_LEN]; //配列でないとsprintfでsegmentation faultが発生る．	int i, j;	//TODO ディレクトリ作成をなんとかする	//_mkdir("..\\build_grid_%d_%d", (int)grid_length.x, (int)grid_length.y);	for(i=1;i<grid_size->vertical;i++){		for(j=1;j<grid_size->width;j++){			//ファイル名の作成			sprintf(fname, "..\\build_grid\\grid_map_%d_%d.dat", i, j);			//ファイルのを作成			fileOpenCheck(&fp, fname, "w+");			//建物データの書き込み			build_grid[i][j].p = build_grid[i][j].head;			build_grid[i][j].p = build_grid[i][j].p->next;			while(build_grid[i][j].p != NULL){				fprintf(fp, "%f %f\n", build_grid[i][j].p->pos.x, build_grid[i][j].p->pos.y);				build_grid[i][j].p = build_grid[i][j].p->next;			}		}	}		return;}//グリッドマップの生成struct build_grid_t** createGridMap(struct build_pos_t* head, struct build_grid_t** build_grid, struct grid_size_t* grid_size){	struct min_max_t whole_map_end_y;  //グリッドのy座標に対する始端と終端	struct min_max_t whole_map_end_x;  //グリッドのx座標に対する始端と終端	struct xy_coord_t grid_length; //各グリッドのxy方向の長さ	int i;		grid_length = g_size;		//全体地図の最小と最大のxy座標を求める．	whole_map_end_y = getEndPointInYaxis(head);	whole_map_end_x = getEndPointInXaxis(head);		grid_size->vertical = (int)(floor((whole_map_end_y.max - whole_map_end_y.min) / grid_length.y) + 2);	grid_size->width =  (int)(floor((whole_map_end_x.max - whole_map_end_x.min) / grid_length.x) + 2);		/* グリッドマップの記憶領域の取得 */	build_grid = (struct build_grid_t *)malloc(sizeof(struct build_grid_t) * grid_size->vertical);	for(i=0;i<grid_size->vertical;i++)		build_grid[i] = (struct build_grid_t *)malloc(sizeof(struct build_grid_t) * grid_size->width);			assignGridArea(build_grid, grid_length, whole_map_end_y, whole_map_end_x, grid_size);		assignBuildToGrid(head, build_grid, grid_size);		if(PRINT_GRID_MAP == 1)		fprintGridMap(build_grid, grid_size);		return build_grid;}		