#include<stdio.h>#include<stdlib.h>#include<string.h>#include"header.h"#define TRUE 1#define FALSE 0void serchRouteDijkstra(struct vertex_t* vertex, int node_size, int start, int goal){	double dist[node_size], min_dist = INF;	int flag[node_size], visit_node[node_size];	int i, index_num;	double temp_dist;		/* 距離配列と探索配列の初期化 */	for(i=1;i<node_size;i++){		dist[i] = INF;		prev[i] = FALSE;	}		/* 始点ノードまでのコストは0 */	dist[start] = 0.0f;	visit_node[start] = 0;		for(i=1;i<node_size;i++){		min_dist = INF;		/* 最小節点の探索 */		for(j=1;j<node_size;j++){			if(flag[j] == FALSE && (dist[j] < min_dist || dist[j] != INF)){				index_num = dist[j];				min_dist = dist[j];			}		}		/* 最小距離の節点に確定フラグを立てる */		flag[index_num] = TRUE;				/* start->goalが連結していない場合のエラー */		if(min_dist == INF){			printf("cannnot arrival goal\n");			printf("%d -> %d\n" ,start, goal);			exit(1);		}		while(vertex[i].adj_list_p != NULL){			temp_dist = getDist(vertex[index_num].node.pos, vertex[vertex[index_num].adj_list_p->num].node.pos); 			if(dist[index_num] +  temp_dist < dist[vertex[index_num].adj_list_p->num]){				dist[vertex[index_num].adj_list_p->num] = dist[index_num] + temp_dist;				visit_node[j] = index_num;			}			vertex[index_num].adj_list_p = vertex[index_num].adj_list_p->next;		}		if(index_num == goal)			break;	}					return;}